
import makeWASocket, { useMultiFileAuthState, DisconnectReason } from '@whiskeysockets/baileys'
import P from 'pino'
import { createRequire } from 'module'
import axios from 'axios'
import qrcode from 'qrcode-terminal'

const require = createRequire(import.meta.url)

// Estado global para controle de reconex√£o e QR
let currentSocket = null
let reconnectAttempts = 0
let qrRefreshInterval = null
let wss = null // WebSocket server para UI

async function baileysProvider(webSocketServer = null) {
    wss = webSocketServer
    console.log('üöÄ Iniciando provider Baileys...')
    
    try {
        const { state, saveCreds } = await useMultiFileAuthState('./auth_info_baileys')
        
        const sock = makeWASocket({
            auth: state,
            printQRInTerminal: false, // Controlamos manualmente
            logger: P({ level: 'silent' }),
            browser: ['Sofia Bot', 'Chrome', '1.0.0'],
            defaultQueryTimeoutMs: 60000,
            keepAliveIntervalMs: 30000
        })

        currentSocket = sock

        sock.ev.on('creds.update', saveCreds)

        sock.ev.on('connection.update', async (update) => {
            const { connection, lastDisconnect, qr } = update
            
            // Gerenciar QR Code
            if (qr) {
                console.log('üì± QR Code gerado:')
                qrcode.generate(qr, { small: true })
                
                // Enviar QR para WebSocket (UI)
                if (wss) {
                    broadcastToClients({ type: 'qr', qrCode: qr })
                }
                
                // Auto-refresh do QR a cada 60 segundos
                if (qrRefreshInterval) clearInterval(qrRefreshInterval)
                qrRefreshInterval = setInterval(() => {
                    console.log('üîÑ Refreshing QR Code...')
                    sock.logout().catch(() => {})
                    setTimeout(() => baileysProvider(wss), 2000)
                }, 60000)
            }
            
            if (connection === 'close') {
                if (qrRefreshInterval) {
                    clearInterval(qrRefreshInterval)
                    qrRefreshInterval = null
                }
                
                const shouldReconnect = (lastDisconnect?.error)?.output?.statusCode !== DisconnectReason.loggedOut
                console.log('‚ö†Ô∏è Conex√£o fechada. Reconectando:', shouldReconnect)
                
                if (wss) {
                    broadcastToClients({ type: 'connection', status: 'disconnected' })
                }
                
                if (shouldReconnect && reconnectAttempts < 5) {
                    reconnectAttempts++
                    console.log(`üîÑ Tentativa de reconex√£o ${reconnectAttempts}/5`)
                    setTimeout(() => baileysProvider(wss), 5000)
                } else if (reconnectAttempts >= 5) {
                    console.log('‚ùå M√°ximo de tentativas de reconex√£o atingido')
                    reconnectAttempts = 0
                }
            } else if (connection === 'open') {
                reconnectAttempts = 0
                if (qrRefreshInterval) {
                    clearInterval(qrRefreshInterval)
                    qrRefreshInterval = null
                }
                
                console.log('‚úÖ Sofia conectada ao WhatsApp!')
                
                if (wss) {
                    broadcastToClients({ 
                        type: 'connection', 
                        status: 'connected',
                        phoneNumber: sock.user?.id.split(':')[0] 
                    })
                }
            }
        })

        sock.ev.on('messages.upsert', async (m) => {
            const msg = m.messages[0]
            if (!msg.message || msg.key.fromMe) return

            const from = msg.key.remoteJid
            const messageText = msg.message.conversation || 
                               msg.message.extendedTextMessage?.text || ''

            const fromNumber = from.split('@')[0]
            console.log(`üì± Mensagem de ${fromNumber}: ${messageText}`)

            // Log para WebSocket
            if (wss) {
                broadcastToClients({
                    type: 'message',
                    direction: 'received',
                    from: fromNumber,
                    text: messageText,
                    timestamp: new Date().toISOString()
                })
            }

            try {
                // üß† Processar com Fluxo Neural Sofia
                const { default: FluxoComercial } = await import('../services/fluxo-comercial-enhanced.js')
                const fluxo = new FluxoComercial()
                const resposta = await fluxo.processar(messageText, fromNumber)
                
                // üìä Enviar score do lead para dashboard
                const leadScore = fluxo.obterScore(fromNumber)
                if (wss) {
                    broadcastToClients({
                        type: 'lead_score',
                        phoneNumber: fromNumber,
                        score: leadScore,
                        timestamp: new Date().toISOString()
                    })
                }
                
                if (resposta) {
                    await sock.sendMessage(from, { text: resposta })
                    console.log(`‚úÖ Resposta enviada para ${fromNumber} (Score: ${leadScore})`)
                    
                    // Log resposta para WebSocket
                    if (wss) {
                        broadcastToClients({
                            type: 'message',
                            direction: 'sent',
                            to: fromNumber,
                            text: resposta,
                            timestamp: new Date().toISOString()
                        })
                    }
                }
            } catch (error) {
                console.error('‚ùå Erro ao processar mensagem:', error)
                const errorResponse = 'üòÖ Desculpe, tive um problema t√©cnico. Tente novamente em alguns instantes.'
                
                await sock.sendMessage(from, { text: errorResponse })
                
                if (wss) {
                    broadcastToClients({
                        type: 'error',
                        message: `Erro ao processar mensagem de ${fromNumber}: ${error.message}`,
                        timestamp: new Date().toISOString()
                    })
                }
            }
        })

        // Fun√ß√£o para enviar mensagem (para uso externo)
        global.sendWhatsAppMessage = async (to, message) => {
            try {
                const formattedTo = to.includes('@') ? to : `${to}@s.whatsapp.net`
                await sock.sendMessage(formattedTo, { text: message })
                return { success: true }
            } catch (error) {
                console.error('‚ùå Erro ao enviar mensagem:', error)
                return { success: false, error: error.message }
            }
        }

        return sock
    } catch (error) {
        console.error('‚ùå Erro ao inicializar Baileys:', error)
        if (wss) {
            broadcastToClients({
                type: 'error',
                message: `Erro ao inicializar: ${error.message}`,
                timestamp: new Date().toISOString()
            })
        }
        throw error
    }
}

// Fun√ß√£o para comunica√ß√£o com Sofia IA (Python)
async function askSofia(message, phoneNumber) {
    try {
        const response = await axios.post('http://127.0.0.1:5000/api/process-message', {
            message: message,
            phone_number: phoneNumber,
            timestamp: new Date().toISOString()
        }, {
            timeout: 10000,
            headers: {
                'Content-Type': 'application/json'
            }
        })
        
        return response.data.response || response.data.message
    } catch (error) {
        console.error('‚ùå Erro na comunica√ß√£o com Sofia IA:', error.message)
        
        // Fallback para resposta b√°sica
        return getFallbackResponse(message)
    }
}

// Resposta de fallback quando a IA n√£o est√° dispon√≠vel
function getFallbackResponse(message) {
    const lowerMessage = message.toLowerCase()
    
    if (lowerMessage.includes('agendar') || lowerMessage.includes('consulta')) {
        return `üëã Ol√°! Sou a Sofia, assistente da DED Company.

üìÖ Perfeito! Vou te ajudar a agendar sua consultoria gratuita.

Para prosseguir, preciso saber:
‚Ä¢ Que dia voc√™ prefere?
‚Ä¢ Qual hor√°rio √© melhor para voc√™?

Exemplos:
- "Amanh√£ √†s 14h"
- "Segunda-feira √†s 10h30"

Aguardo sua resposta! üòä`
    }
    
    if (lowerMessage.includes('ol√°') || lowerMessage.includes('oi')) {
        return `üëã Ol√°! Muito prazer!

Sou a Sofia, assistente virtual da DED Company.

üéØ Especializada em assessoria para eventos, posso te ajudar com uma consultoria gratuita.

Como posso te ajudar hoje? Digite "agendar" para marcarmos sua consultoria! üòä`
    }
    
    return `üëã Ol√°! Sou a Sofia, assistente virtual da DED Company.

üéØ Posso ajud√°-lo a agendar uma consultoria gratuita sobre assessoria para eventos.

üìÖ Basta me dizer quando voc√™ gostaria de conversar!

Digite "agendar" para come√ßarmos! üòä`
}

// Fun√ß√£o para broadcast WebSocket
function broadcastToClients(data) {
    if (!wss || !wss.clients) return
    
    const message = JSON.stringify(data)
    wss.clients.forEach(client => {
        if (client.readyState === 1) { // WebSocket.OPEN
            client.send(message)
        }
    })
}

// Fun√ß√£o b√°sica de processamento de mensagem
async function processarMensagem(texto, numero) {
    try {
        // L√≥gica b√°sica de resposta da Sofia
        if (texto.toLowerCase().includes('agendar') || 
            texto.toLowerCase().includes('consulta') ||
            texto.toLowerCase().includes('reuni√£o')) {
            
            return `üëã Ol√°! Sou a Sofia, assistente da DED Company.

üìÖ Perfeito! Vou te ajudar a agendar sua consultoria gratuita.

Para prosseguir, preciso saber:
‚Ä¢ Que dia voc√™ prefere?
‚Ä¢ Qual hor√°rio √© melhor para voc√™?

Exemplos:
- "Amanh√£ √†s 14h"
- "Segunda-feira √†s 10h30"
- "25/12/2024 √†s 15h"

Aguardo sua resposta! üòä`
        }
        
        if (texto.toLowerCase().includes('ol√°') || 
            texto.toLowerCase().includes('oi') ||
            texto.toLowerCase().includes('bom dia') ||
            texto.toLowerCase().includes('boa tarde')) {
            
            return `üëã Ol√°! Muito prazer!

Sou a Sofia, assistente virtual da DED Company.

üéØ Especializada em assessoria para eventos, posso te ajudar com uma consultoria gratuita.

Como posso te ajudar hoje?
‚Ä¢ Agendar uma consultoria
‚Ä¢ Tirar d√∫vidas sobre nossos servi√ßos
‚Ä¢ Falar sobre planejamento de eventos

Digite "agendar" para marcarmos sua consultoria! üòä`
        }

        // Resposta padr√£o
        return `üëã Ol√°! Sou a Sofia, assistente virtual da DED Company.

üéØ Posso ajud√°-lo a agendar uma consultoria gratuita sobre assessoria para eventos.

üìÖ Basta me dizer quando voc√™ gostaria de conversar!

Digite "agendar" para come√ßarmos! üòä`
        
    } catch (error) {
        console.error('Erro ao processar mensagem:', error)
        return 'Desculpe, houve um erro. Tente novamente.'
    }
}

export default baileysProvider
